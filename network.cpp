#include "network.h"
#include <iostream>
#include <time.h>

Network::Network() {
	
	/** Initialisation of the attributes 
	 * related to the random generation
	 */
	mt19937 generator(rd());
	poisson_distribution<> pois_dis_(lambda);
	
	/** It will generate a random index among the excitatatory neurons */ 
	uniform_int_distribution<> ExcitatoryReceivedConnectionsGenerator(0,(n_e-1));
	
	/** It will generate a random index among the inhibitory neurons */
	uniform_int_distribution<> InhibitoryReceivedConnectionsGenerator(n_e,n_e+n_i-1);
		
	int c(0);
	
	/** Let's create the excitatory neurons
	 */
	for(size_t i=0; i < n_e; ++i) {
		neurons_.push_back(Neuron());
		neurons_[i].setE(true);
	}
	/** Here, the main difficulty is that we dont't know the precise number of connections sent by a neuron, and we need this value
	 * but we do know the precise number of connexions received by a neuron (given in the course). 
	 * Before arriving to this code, I was dealing only with the number of connections received, and in the updateNetwork, 
	 * I had to iterate among all the connections of all my neurons. 
	 * It was to complexe. Then, I decide to determine the number of sent connections of each neurons, 
	 * so that I will have to iterate among all the neurons, and then only among the sent connections
	 * (and not among all his connections)
	 * of the neurons which spike
	 */
	
	for(size_t i=0; i < n_e; ++i) {
		/** among all the excitatatory neurons, we chose C_e 
		 * that will be connected to the current excitatatory neuron */   
		for(size_t j=0; j < C_e; j++) {
			c=ExcitatoryReceivedConnectionsGenerator(generator);
			neurons_[i].addReceivedConnection(c);
			neurons_[c].addSentConnection(i);
		}
		/** among all the Inhibitory neurons, we chose C_i 
		 * that will be connected to the current excitatatory neuron */
		for(size_t j=0; j < C_i; ++j) {
			c=InhibitoryReceivedConnectionsGenerator(generator);
			neurons_[i].addReceivedConnection(c);
			neurons_[c].addSentConnection(i);
		}
	}
	
	/** Let's create the inhibitory neurons
	 */
	for(size_t i=0; i < n_i; ++i) {
		neurons_.push_back(Neuron());
		neurons_[n_e+i].setE(false);
	}
	for(size_t i=0; i < n_i; ++i) {
		/** among all the excitatatory neurons, we chose C_e 
		 * that will be connected to the current inhibitory neuron */
		for(size_t j=0; j < C_e; ++j) {
			c=ExcitatoryReceivedConnectionsGenerator(generator);
			neurons_[n_e+i].addReceivedConnection(c);
			neurons_[c].addSentConnection(n_e+i);
		}
		/** among all the inhibitory neurons, we chose C_i 
		 * that will be connected to the current inhibitory neuron */
		for(size_t j=0; j < C_i; ++j) {
			c=InhibitoryReceivedConnectionsGenerator(generator);
			neurons_[n_e+i].addReceivedConnection(c);
			neurons_[c].addSentConnection(n_e+i);
		}
	}
}

vector<Neuron> Network::getNeurons() const{
	return neurons_;
}

void Network::update() {
	for(size_t i=0; i < n_neurons; ++i) {
		/** The noise is generated by a poisson distribution*/
		if(neurons_[i].update(J_e*pois_dis_(generator))) {
			for(auto con : neurons_[i].getSentConnections()){
				neurons_[con].setBuffer(neurons_[i].getE());
				//neurons_[con].addReceivedSpike(neurons_[con].getClock());    // decomment for the second gtest
			}		
		}
	}
}

void Network::simulation(int t_start, int t_stop) {
	int t(t_start);
	while(t<t_stop) {
		update();
		t+=h;
		cout<<t<<endl;
	}
}

void Network::file() {
	ofstream neuron_graph;
	neuron_graph.open("NeuronGraph.txt");
	for(size_t i=0; i < n_neurons; ++i) {
		for(size_t j=0; j<neurons_[i].getSpikes().size(); ++j) {
			neuron_graph << neurons_[i].getSpikes()[j] << "\t" << i+1 << endl;
		}
	}
	neuron_graph.close();
}
	
			
	
	
	
	
				
















/*
		for(size_t j=0; j < C_tot; j++) {    //we iterate on each connection of each neuron
			if(neurons_[neurons_[i].getConnections()[j]].getSpike()) {    //if the neuron at the jth case of the vector connections_ is spiking (in each case of connections_, we have the number (in neurons_) of the neuron that is connected to the current neuron)
				neurons_[i].setBuffer();    // à revoir : prendre en compte l'état (excitateur ou pas) du neuronne qui envoi le spike
			}
		}
	}
}
*/
			
		
		


		 
	
	
